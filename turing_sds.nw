\documentclass[11pt]{article}

% \documentclass[twocolumn,12pt]{article}
\usepackage{hyperref}
\usepackage{noweb}
\noweboptions{longxref,alphasubpage,subscriptidents,subscriptquotedidents,longchunks}

% % Set up formatting to look more like a modern report than an old book.
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Default Geometry
\usepackage[a4paper]{geometry}
% \usepackage[margin=0.5in, paperwidth=14.15in, paperheight=11.25in]{geometry} % 1280 x 1024 Monitor reading
% \usepackage[margin=0.5in, paperwidth=16.5in, paperheight=9.25in]{geometry} % 1600 x 900 Monitor reading (ThinkPad)
% \usepackage[margin=0.5in, paperwidth=19.9in, paperheight=11.1in]{geometry} % 1920 x 1080 Monitor reading (MultiSync EA234WMi)
% \usepackage[margin=0.5in, paperheight=19.9in, paperwidth=11.1in]{geometry} % 1080 x 1920 Monitor reading (Portrait MultiSync EA234WMi)
\usepackage{microtype}

\setlength{\columnsep}{1in}
\setlength{\columnseprule}{1px}

\newcommand{\vref}[1]{\ref{#1},~p.\pageref{#1}}

\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\title{A Turing Complete SDS}
\author{Andrew Owen Martin}

\pagestyle{noweb}

\begin{document}
\maketitle
\tableofcontents

\section{Addition}
See Figure~\vref{fig:add}.
\begin{figure}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=2cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
\begin{tikzpicture}[node distance=2cm]
%\node (A) [startstop] {Start};
\node (init) [startstop] {$x:=2$, $y:=3$};
\node (eqz) [startstop,below left of=init] {$x==0$?};
\node (gtz) [startstop,below right of=init] {$x>0$?};
\node (dec) [startstop,below of=gtz] {DEC $x$};
\node (inc) [startstop,below of=dec] {INC \(y\)};
\node (halt) [startstop,below of=eqz] {Halt};
%\draw [arrow] (init) -- (eqz);
%\draw [arrow] (init) -- (gtz);
%\draw [arrow] (gtz) -- (dec);
%\draw [arrow] (dec) -- (inc);
%\draw [arrow] (inc.west) -- ++(-0.5,0) |- (eqz.east);
%\draw [arrow] (inc.east) -| ++(0.5,0) |- (gtz.east);
%\draw [arrow] (eqz) -- (halt);
\draw [arrow] (eqz) -- (init);
\draw [arrow] (gtz) -- (init);
\draw [arrow] (dec)  -- (gtz);
\draw [arrow] (inc)  -- (dec);
\draw [arrow] (eqz.east) -- ++(0.5,0) |- (inc.west);
\draw [arrow] (gtz.east) -| ++(0.5,0) |- (inc.east);
\draw [arrow] (halt) -- (eqz);
\end{tikzpicture}
\label{fig:add}
\caption{Addition flow chart}
\end{figure}

\begin{table}
	\centering
	\begin{tabular}{@{}rlcc@{}}
		State & Action & Next state if $x==0$ & Next state if $x>0$
		\\\midrule
		1 & Init & 4 & 2 \\
		2 & DEC $x$ & 3 & 3 \\
		3 & INC $y$ & 4 & 2 \\
		4 & Halt & 4 & 4\\
	\end{tabular}
\caption{Norma addition truth table}
\label{tab:add}
\end{table}

\section{Addition execution trace}

Running code of Table~\vref{tab:add} if `Init' is $x=2$, $y=1$ can be seen in Table~\vref{tab:trace}.

\begin{table}
	\centering
	\begin{tabular}{@{}llll@{}}
Step&State& x&y
\\\midrule
0   & Init  &2&1\\
1   & $x > 0$ and not $x == 0$&2&1\\
2   & DEC $x$ &1&1\\
3   & INC $y$ &1&2\\
4   & $x > 0$ and not $x == 0$ &1&2\\
5   & DEC $x$ &0&2\\
6   & INC $y$ &0&3\\
7   & $x == 0$ and not $x > 0$&0&3\\
8   & Halt  &0&3\\
	\end{tabular}
\caption{Norma addition execution trace}
\label{tab:trace}
\end{table}

\section{Introduction}

Turing SDS can do anything NORMA2 can do.
NORMA2 has been proven Turing complete.
It runs similarly to standard SDS, I can even use diffusion phase and test phase functions from my library.
The differences lay in the microtests, and random hypothesis function.

\subsection{New Hypotheses}
New hypotheses are generated thus, poll a random agent.

If that agent is not active then assume the hypothesis of the initial state. As follows:
\begin{description}
\item[previous $x$]= \texttt{null}
\item[previous $y$]= \texttt{null}
\item[previous state]= \texttt{null}
\item[current $x$]= (Something hardcoded) e.g. 2
\item[current $y$]= (Something hardcoded) e.g. 3
\item[current state]= 1
\end{description}

If the polled agent is active initialise your ``previous'' values with their ``current'' values. Make new $x$ and $y$ values by taking their ``current'' $x$ and $y$ values and apply one of the operations {no change, inc $x$, inc $y$, dec $x$, dec $y$\}, assume the ``current state'' by looking at the truth table for the polled agents ``current state'' and taking either the next state from the ``$x$ equals zero'' column, or the ``$x$ greater than zero'' column. Return your new hypothesis.


\subsection{Microtests}
There is one microtest, it takes a hypothesis and returns True if the register values are valid and the selected state is valid.

Registers are valid if the difference between your hypothesised ``previous $x$ and $y$'' and your hypothesised ``current $x$ and $y$'' is the difference expected from the action at your hypothesised ``current state''. The state is valid if the ``previous $x$'' is \texttt{null} (i.e. this is the initial state) or if ``previous $x$'' was equal to zero and the hypothesised ``current state'' is the state to transition into when the ``previous state'' had $x$ equal to zero, or if ``previous $x$'' was greater than zero and the hypothesised ``current state'' is the state to transition into when the ``previous state'' had $x$ greater than zero.

\subsection{Data structures}
<<data structures>>=
Truth = namedtuple('Truth',('state_num','action','xeq0','xgt0'))
State = namedtuple('State',('state','x','y'))
Hypothesis = namedtuple('Hypothesis',('previous','current'))
@

\subsection{NORMA2 Operations}
The variables [[px]] and [[py]] refer to hypothesised previous register values, and [[x]] and [[y]] refer to hypothesised current register values. The operations of NORMA2 are thus defined.
<<norma2 operations>>=
inc_x = lambda px,py,x,y: x == px+1 and y == py
inc_y = lambda px,py,x,y: x == px and y == py+1
dec_x = lambda px,py,x,y: x == px-1 and y == py
dec_y = lambda px,py,x,y: x == px and y == py-1
init = lambda px,py,x,y: px is None and py is None
halt = lambda px,py,x,y: x == px and y == py
@

\subsection{Truth table in python}
<<addition truth table>>=
# Truth table for '2x + y'
truth_table = {
	1:Truth(state_num=1, action=init,  xeq0=5, xgt0=2),
	2:Truth(state_num=2, action=dec_x, xeq0=3, xgt0=3),
	3:Truth(state_num=3, action=inc_y, xeq0=4, xgt0=4),
	4:Truth(state_num=4, action=inc_y, xeq0=5, xgt0=2),
	5:Truth(state_num=5, action=halt,  xeq0=5, xgt0=5),
}

# Truth table for 'Add x + y'
#truth_table = {
#	1:Truth(state_num=1, action=init,  xeq0=4, xgt0=2),
#	2:Truth(state_num=2, action=dec_x, xeq0=3, xgt0=3),
#	3:Truth(state_num=3, action=inc_y, xeq0=4, xgt0=2),
#	4:Truth(state_num=4, action=halt,  xeq0=4, xgt0=4),
#}
@

<<imports>>=
from collections import namedtuple
@

\subsection{Random hypothesis function}
<<random hypothesis function>>=
def random_hypothesis_function(random, swarm, initial_state):

	polled_agent = random.choice(swarm)

	if polled_agent.active:

		old_hyp = polled_agent.hypothesis.current

		peturbation = random.choice((
			lambda x,y: (x,y),
			lambda x,y: (x+1,y),
			lambda x,y: (x-1,y),
			lambda x,y: (x,y+1),
			lambda x,y: (x,y-1),),)

		new_x,new_y = peturbation(old_hyp.x,old_hyp.y)

		old_state = truth_table[old_hyp.state]

		new_state = random.choice( (old_state.xeq0, old_state.xgt0,) )

		new_hyp = Hypothesis(
			current=State(state=new_state,x=new_x,y=new_y),
			previous=State(
				state=old_hyp.state,
				x=old_hyp.x,
				y=old_hyp.y),)

	else:

		new_hyp = Hypothesis(
			current=initial_state,
			previous=State(state=None,x=None,y=None)
		)

	return new_hyp
@

<<imports>>=
import random
@

\subsection{Microtests}
<<microtests>>=
def microtest(h):

	previous = h.previous
	current = h.current

	action = truth_table[current.state].action
	prev_truth = truth_table.get(previous.state)

	registers_are_valid = action(
		previous.x,
		previous.y,
		current.x,
		current.y,)

	state_is_valid = (
		previous.x is None
		or ((previous.x == 0) and (prev_truth.xeq0 == current.state))
		or ((previous.x > 0) and (prev_truth.xgt0 == current.state))
	)

	return registers_are_valid and state_is_valid

microtests = [
	microtest
]
@

\subsection{Execution}

This uses context sensitive diffusion, when I diffused the swarm asynchronously convergence appeared to happen about twice as fast.

<<run turing sds>>=
def run_turing_sds(swarm, max_iterations):

	new_hyp_func = functools.partial(
		random_hypothesis_function,
		swarm=swarm,
		initial_state=State(state=1,x=6,y=3),
	)

	for iteration in range(max_iterations):
		print(iteration)

		sds.context_sensitive_diffusion(swarm, random, new_hyp_func)

		sds.test_phase(swarm, microtests, random)

		for agent in swarm:

			if agent.active:

				agent_state = truth_table[agent.hypothesis.current.state]

				if agent_state.action is halt:

					success = agent

					print(
						'At iteration',iteration,
						' y :=',success.hypothesis.current.y)
					return
@

<<imports>>=
import functools
@

\subsection{Execution test}
<<test>>=
def test():
	swarm = sds.Agent.initialise(100)
	run_turing_sds(swarm, max_iterations=100000)

do_test = True
if do_test:
	test()
@

<<imports>>=
import sds
from pprint import pprint
@

\subsection{Script}
<<*>>=
<<imports>>
<<data structures>>
<<norma2 operations>>
<<addition truth table>>
<<random hypothesis function>>
<<microtests>>
<<run turing sds>>
<<test>>
@


%\appendix{}
%
%\section{Index}
%
%\nowebindex{}
%
%\section{Code Chunks}
%
%\nowebchunks{}

\end{document}

