\documentclass[11pt]{article}

% \documentclass[twocolumn,12pt]{article}
\usepackage{hyperref}
\usepackage{noweb}
\noweboptions{longxref,alphasubpage,subscriptidents,subscriptquotedidents,longchunks}

% % Set up formatting to look more like a modern report than an old book.
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Default Geometry
\usepackage[a4paper]{geometry}
% \usepackage[margin=0.5in, paperwidth=14.15in, paperheight=11.25in]{geometry} % 1280 x 1024 Monitor reading
% \usepackage[margin=0.5in, paperwidth=16.5in, paperheight=9.25in]{geometry} % 1600 x 900 Monitor reading (ThinkPad)
% \usepackage[margin=0.5in, paperwidth=19.9in, paperheight=11.1in]{geometry} % 1920 x 1080 Monitor reading (MultiSync EA234WMi)
% \usepackage[margin=0.5in, paperheight=19.9in, paperwidth=11.1in]{geometry} % 1080 x 1920 Monitor reading (Portrait MultiSync EA234WMi)
\usepackage{microtype}

\setlength{\columnsep}{1in}
\setlength{\columnseprule}{1px}

\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\title{A Turing Complete SDS}
\author{Andrew Owen Martin}

\pagestyle{noweb}

\begin{document}
\maketitle
\tableofcontents

\section{Addition}
\begin{figure}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=2cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
\begin{tikzpicture}[node distance=2cm]
%\node (A) [startstop] {Start};
\node (init) [startstop] {$x:=2$, $y:=3$};
\node (eqz) [startstop,below left of=init] {$x==0$?};
\node (gtz) [startstop,below right of=init] {$x>0$?};
\node (dec) [startstop,below of=gtz] {DEC $x$};
\node (inc) [startstop,below of=dec] {INC \(y\)};
\node (halt) [startstop,below of=eqz] {Halt};
%\draw [arrow] (init) -- (eqz);
%\draw [arrow] (init) -- (gtz);
%\draw [arrow] (gtz) -- (dec);
%\draw [arrow] (dec) -- (inc);
%\draw [arrow] (inc.west) -- ++(-0.5,0) |- (eqz.east);
%\draw [arrow] (inc.east) -| ++(0.5,0) |- (gtz.east);
%\draw [arrow] (eqz) -- (halt);
\draw [arrow] (eqz) -- (init);
\draw [arrow] (gtz) -- (init);
\draw [arrow] (dec)  -- (gtz);
\draw [arrow] (inc)  -- (dec);
\draw [arrow] (eqz.east) -- ++(0.5,0) |- (inc.west);
\draw [arrow] (gtz.east) -| ++(0.5,0) |- (inc.east);
\draw [arrow] (halt) -- (eqz);
\end{tikzpicture}
\end{figure}

\begin{table}
	\centering
	\begin{tabular}{@{}lllll@{}}
		State & Action & $x==0$ & $x>0$
		\\\midrule
		1 & Init & 4 & 2 \\
		2 & DEC $x$ & 3 & 3 \\
		3 & INC $y$ & 4 & 2 \\
		4 & Halt & 4 & 4\\
	\end{tabular}
\caption{Norma addition truth table}
\label{tab:add}
\end{table}

\section{Addition execution trace}

Running code of Table~\ref{tab:add} if `Init' is $x=2$, $y=1$.

\begin{table}
	\centering
	\begin{tabular}{@{}llll@{}}
Step&State& x&y
\\\midrule
0   & Init  &2&1\\
1   & $x > 0$ and not $x == 0$&2&1\\
2   & DEC $x$ &1&1\\
3   & INC $y$ &1&2\\
4   & $x > 0$ and not $x == 0$ &1&2\\
5   & DEC $x$ &0&2\\
6   & INC $y$ &0&3\\
7   & $x == 0$ and not $x > 0$&0&3\\
8   & Halt  &0&3\\
	\end{tabular}
\caption{Norma addition execution trace}
\label{tab:trace}
\end{table}

\section{Sequential converging swarms}
Run a swarm to convergence then run all the swarms pointing at it.

This has been nearly implemented. \texttt{thesis/src/sds\_comp\_2.py} runs and does NORMA2 style addition, but it's a bit hacky and not very satisfying.

\section{Move individual agents}

Move agents around. They're in a position and their hypothesis is any of the tests pointing in to that position.

Each inactive agent polls a random agent from a random state, and if the polled agent is active, then polling assumes hypothesis of polled and becomes active if hypothesis passes the test of the state. No start state, if you pick \texttt{(B: x=2, y=3)} then you are guaranteed happy, but then we will need context-sensitive to stop everyone getting caught in \texttt{(B)}.

Alternatively, if an agent has its hypothesis copied, it becomes inactive.

\section{Wandering agents}

Just have agents moving around. But that's not very SDS.

\section{Hypothesis as next state}

I'll list the states, and the agents can hypothesise that the next state is the one where execution moves to.

So I'll put the agents in state A, and one will hypothesise that the next state is B, and one will hypothesise that the next state is C.
They'd then have to pick a test, and the test might be INC, DEC, or $x=0$.

So the agent will go, I think the next state is C. And I know it is because the test ``INC'' against the parameters ``from B to C'' passes. B is the current state, and C is the hypothesis. Maybe you know the current state from other agents hypothesis. So they all start as \texttt{hyp=A} and active. Then the ``random hypothesis generation'' is to accept the hypothesis from a random agent. So they're active...

\section{Microtests as truth table}

So if I make the hypotheses the current state, and the tests the truth table, then what do I get?

Each agent randomly assumes a state as a hypothesis. So we have some agents as 1, some at 2, some at 3, and some at 4. The question is where do the registers come in? I don't really want to randomly generate them. I could reword Table~\ref{tab:add} as these rules.

\begin{enumerate}
\item If there is activity in state 1 at $(x,y)$ and $x>0$, there should be activity in state 2 at $(x-1,y)$.
\item If there is activity in state 2 at $(x,y)$, there should be activity in state 3 at $(x,y-1)$.
\item If there is activity in state 3 at $(x,y)$ and $x>0$, there should be activity in state 2 at $(x-1,y)$.
\item If there is activity in state 1 at $(x,y)$ and $x==0$, there should be any activity in state 4.
\item If there is activity in state 3 at $(x,y)$ and $x==0$, there should be any activity in state 4.
\item If there is activity in state 4 then halt.
\end{enumerate}

Then how do I handle the conflict between ``
If there is activity in state 1 at $(x,y)$ and $x>0$, there should be activity in state 2 at $(x-1,y)$.
'' and ``
If there is activity in state 3 at $(x,y)$ and $x>0$, there should be activity in state 2 at $(x-1,y)$.
''

I can handle this in two ways, either ensure that it can handle multiple static activities or destroy old behaviour somehow.

\subsection{Multiple activities}

\subsection{Destroying old activity}

\section{Hypothesise the answer}

Could you hypothesise the answer, and work backwards from the halting state? For your hypothesised $y$ register value, you could pick a rule at random, and see if it would have led you there?

You could also hypothesise a whole system trace, and see if any of them would have worked.

\section{Hypothesis as State,X,Y tuple}

This might not be so bad as a random hypothesis is only going to be an X one bigger or smaller, and Y only one bigger or smaller.

Make a hyp which is selecting someone at random, then mutating the state and one of X or Y, if it works then set them inactive and become active.

Is this more SDS-like if each agent modifies them self? I don't think so. Can we have each agent doing context sensitive?

2 active agents, one active at (id,state,x,y,active) (1,1,2,1,T), the other inactive.
Diffusion phase. Each agent selects an agent at random, if they get an active agent they diffuse the hypothesis with some mutation. say (2,2,2,1,F) then we have to test if you can get from (1,2,1) to (2,2,1). If so the second agent is active. That leaves us with (1,1,2,1,T) and (2,2,2,1,T) and now nothing else can happen.

But does that have testing and diffusion? The test can be to pick a rule from the truth table and see if it matches?

\subsection{Data structures}
<<data structures>>=
Truth = namedtuple('Truth',('state_num','action','xeq0','xgt0'))
State = namedtuple('State',('state','x','y'))
Hypothesis = namedtuple('Hypothesis',('previous','current'))
@

\subsection{Truth table in python}
<<addition truth table>>=
inc_x = lambda px,py,x,y: x == px+1 and y == py
inc_y = lambda px,py,x,y: x == px and y == py+1
dec_x = lambda px,py,x,y: x == px-1 and y == py
dec_y = lambda px,py,x,y: x == px and y == py-1
init = lambda px,py,x,y: px is None and py is None
halt = lambda px,py,x,y: x == px and y == py

# Truth table for '2x + y'
truth_table = {
	1:Truth(state_num=1, action=init,  xeq0=5, xgt0=2),
	2:Truth(state_num=2, action=dec_x, xeq0=3, xgt0=3),
	3:Truth(state_num=3, action=inc_y, xeq0=4, xgt0=4),
	4:Truth(state_num=4, action=inc_y, xeq0=5, xgt0=2),
	5:Truth(state_num=5, action=halt,  xeq0=5, xgt0=5),
}

# Truth table for 'Add x + y'
#truth_table = {
#	1:Truth(state_num=1, action=init,  xeq0=4, xgt0=2),
#	2:Truth(state_num=2, action=dec_x, xeq0=3, xgt0=3),
#	3:Truth(state_num=3, action=inc_y, xeq0=4, xgt0=2),
#	4:Truth(state_num=4, action=halt,  xeq0=4, xgt0=4),
#}
@

<<imports>>=
from collections import namedtuple
@

\subsection{Random hypothesis function}
<<random hypothesis function>>=
def random_hypothesis_function(random, swarm, initial_state):

	polled_agent = random.choice(swarm)

	if polled_agent.active:

		old_hyp = polled_agent.hypothesis

		peturbation = random.choice(
			(
				lambda x,y: (x,y),
				lambda x,y: (x+1,y),
				lambda x,y: (x-1,y),
				lambda x,y: (x,y+1),
				lambda x,y: (x,y-1),
			)
		)

		new_x,new_y = peturbation(old_hyp.current.x,old_hyp.current.y)

		old_state = truth_table[old_hyp.current.state]

		new_state = random.choice( (old_state.xeq0, old_state.xgt0,) )

		new_hyp = Hypothesis(
			current=State(state=new_state,x=new_x,y=new_y),
			previous=State(state=old_hyp.current.state,x=old_hyp.current.x,y=old_hyp.current.y)
		)

	else:

		new_hyp = Hypothesis(
			current=initial_state,
			previous=State(state=None,x=None,y=None)
		)

	return new_hyp
@

<<imports>>=
import random
@

\subsection{Microtests}
<<microtests>>=
def microtest(h):

	previous = h.previous
	current = h.current

	action = truth_table[current.state].action
	prev_truth = truth_table.get(previous.state)

	registers_are_valid = action(
		previous.x,
		previous.y,
		current.x,
		current.y,)

	state_is_valid = (
		previous.x is None
		or ((previous.x == 0) and (prev_truth.xeq0 == current.state))
		or ((previous.x > 0) and (prev_truth.xgt0 == current.state))
	)

	return registers_are_valid and state_is_valid

microtests = [
	microtest
]
@

\subsection{Execution}

This uses context sensitive diffusion, when I diffused the swarm asynchronously convergence appeared to happen about twice as fast.

<<run turing sds>>=
def run_turing_sds(swarm, max_iterations):

	new_hyp_func = functools.partial(
		random_hypothesis_function,
		swarm=swarm,
		initial_state=State(state=1,x=6,y=3),
	)

	for iteration in range(max_iterations):
		print(iteration)

		sds.context_sensitive_diffusion(swarm, random, new_hyp_func)

		sds.test_phase(swarm, microtests, random)

		for agent in swarm:

			if agent.active:

				agent_state = truth_table[agent.hypothesis.current.state]

				if agent_state.action is halt:

					success = agent

					print(
						'At iteration',iteration,
						' y :=',success.hypothesis.current.y)
					return
@

<<imports>>=
import functools
@

\subsection{Execution test}
<<test>>=
def test():
	swarm = sds.Agent.initialise(100)
	run_turing_sds(swarm, max_iterations=100000)

do_test = True
if do_test:
	test()
@

<<imports>>=
import sds
from pprint import pprint
@

\subsection{Script}
<<*>>=
<<imports>>
<<data structures>>
<<addition truth table>>
<<random hypothesis function>>
<<microtests>>
<<run turing sds>>
<<test>>
@

\section{Explanation}

Turing SDS can do anything NORMA2 can do.
NORMA2 has been proven turing complete.
It runs similarly to standard SDS, I can even use diffusion phase and test phase functions from my library.
The differences lie in the microtests, and random hypothesis function.

\subsection{New Hypotheses}
New hypotheses are generated thus, poll a random agent, if that agent is not active then assume the hypothesis of the initial state.
\begin{description}
\item[previous x] \texttt{null}
\item[previous y] \texttt{null}
\item[previous state] \texttt{null}
\item[current x] (Something hardcoded) e.g. 2
\item[current y] (Something hardcoded) e.g. 3
\item[current state] 1
\end{description}

If the polled agent is active initialise your ``previous'' values with their ``current'' values. Make new x and y values by taking their ``current'' x and y values and apply one of the operations {no change, inc x, inc y, dec x, dec y}, assume the ``current state'' by looking at the truth table for the polled agents ``current state'' and taking either the next state from the ``x equals zero'' column, or the ``x greater than zero'' column. Return your new hypothesis.


\subsection{Microtests}
There is one microtest, it takes a hypothesis and returns True if the register values are valid and the selected state is valid.

Registers are valid if the difference between your hypothesised ``previous x and y'' and your hypothesised ``current x and y'' is the difference expected from the action at your hypothesised ``current state''. The state is valid if the ``previous x'' is \texttt{null} (i.e. this is the initial state) or if ``previous x'' was equal to zero and the hypothesised ``current state'' is the state to transition into when the ``previous state'' had x equal to zero, or if ``previous x'' was greater than zero and the hypothesised ``current state'' is the state to transition into when the ``previous state'' had x greater than zero.

\appendix{}

\section{Index}

\nowebindex{}

\section{Code Chunks}

\nowebchunks{}

\end{document}

