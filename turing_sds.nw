\documentclass[11pt]{article}

% \documentclass[twocolumn,12pt]{article}
\usepackage{hyperref}
\usepackage{noweb}
\usepackage{graphicx}
\noweboptions{longxref,alphasubpage,subscriptidents,subscriptquotedidents,longchunks}

% % Set up formatting to look more like a modern report than an old book.
\setlength{\parindent}{0em}
\setlength{\parskip}{1em}

% Default Geometry
\usepackage[a4paper]{geometry}
% \usepackage[margin=0.5in, paperwidth=14.15in, paperheight=11.25in]{geometry} % 1280 x 1024 Monitor reading
% \usepackage[margin=0.5in, paperwidth=16.5in, paperheight=9.25in]{geometry} % 1600 x 900 Monitor reading (ThinkPad)
% \usepackage[margin=0.5in, paperwidth=19.9in, paperheight=11.1in]{geometry} % 1920 x 1080 Monitor reading (MultiSync EA234WMi)
% \usepackage[margin=0.5in, paperheight=19.9in, paperwidth=11.1in]{geometry} % 1080 x 1920 Monitor reading (Portrait MultiSync EA234WMi)
\usepackage{microtype}
\usepackage[UKenglish]{isodate}% http://ctan.org/pkg/isodate
\cleanlookdateon% Remove ordinal day reference

\setlength{\columnsep}{1in}
\setlength{\columnseprule}{1px}

\newcommand{\vref}[1]{\ref{#1},~p.\pageref{#1}}

\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\title{A Turing Complete SDS}
\author{Andrew Owen Martin}

\pagestyle{noweb}

\begin{document}
\maketitle
\tableofcontents

\section{Preliminary assumptions}

To go from something like NORMA2 to a new swarmy implementation, we need to know what things we can and cannot change.

Firstly, when designing a NORMA2 program, to perform addition for example, then an intelligent user still needs to determine the procedure themselves. This means we can get away with manually specifying the shape of the program, and should not expect the intended function to emerge without such careful initialisation. Because of this, I will often refer to the state table which defines a NORMA2 machine for addition (Table~\ref{tab:add}); in a properly swarmy system, there will not be an explicit state table, but the emergent behaviour will have to be similar to one, and this will largely have to be the result of manual configuration by a user.

\begin{table}
	\centering
	\begin{tabular}{@{}rlcc@{}}
		State & Action & if $x=0$ goto & if $x>0$ goto
		\\\midrule
		1 & Init & 4 & 2 \\
		2 & DEC $x$ & 3 & 3 \\
		3 & INC $y$ & 4 & 2 \\
		4 & Halt & 4 & 4\\
	\end{tabular}
\caption{Norma addition truth table}
\label{tab:add}
\end{table}

Secondly, NORMA2 was given some registers of unlimited size which is fine in practise, but if I were to implement NORMA2, in Python for example, then I would need to include special routines for times when the value of the registers was larger than could fit into memory. This could be a function which stops the NORMA2 procedure before the register values become too big, and informs the user to go and install more memory into the machine. The point is, that any implementation I can do in a few minutes would not be able to perform certain computations over a certain size. I therefore suggest that we should not expect the swarmy implementation to work for all cases either, though in theory it should.

Lastly, the capabilities of NORMA are incrementing, decrementing, branching, and comparison with zero. We will need either the same set of capabilities, or a similarly expressive set.

With these assumptions in mind, lets consider a few approaches.

\section{Just copy NORMA2}

If I implemented something exactly like NORMA2, then we know for sure that it would work, but we would be criticised for demonstrating something that is neither original or swarmy. So from this basis, what's the minimum change we could do to make a system that would still work, by virtue of its being almost identical to NORMA2, but with some swarmy aspect?

Imagine a swarm of one agent, where their behaviour was entirely determined by the state table. The agent would maintain a state and two register values, and update them according to the states. Again, this would definitely work, but not be sufficciently swarmy, as there is no agent-to-agent interaction, and the behaviour of the agent is explicit and complicated.

So we need more than one agent, is there any way that two agents could be used? Maybe if one agent simply maintained a boolean state depending on whether it held that $x=0$. Then you could have one agent maintaining the registers and state, and branching depending on the state of the other agent. This could also certainly be made to work, but now we have the criticism that the two distinct types of agent makes this more of a multi-agent system rather than a swarm intelligence system.

So could it be done with two identical agents? One would need to maintain a state and the other would have to find the next state. The agent which found the next state would have to deactivate the other agent so the newly inactive agent may find the next state. They would go on leap-frogging each other. Let's see if that's at all viable.

\subsection{Two agent solution}

First we'll import some bits, and define an Agent as something which has an activity and a hypothesis, and a `Step' which defines a state of a computational procedure, representing the value of the X and Y registers and the current state it is in.

<<two-agent-solution.py>>=
import random
from collections import namedtuple

Step = namedtuple('Step',['x','y','state'])

class Agent:
	def __init__(self):
		self.active = False
		self.hyp = None
@

Then we'll define a swarm as two of those agents, and define the function for generating new hypothesis, which in this case returns the initial Step, where $X=2$, $Y=1$, in State 1.

<<two-agent-solution.py>>=
swarm = tuple(Agent() for _ in range(2))

def initial_hyp():
	return Step(x=3,y=2,state=1)
@

Now we need a diffusion phase.
I've chosen to disallow self-selection, and use standard passive diffusion, and hypothesis transmission error, where the registers have a small chance of being perturbed and the state is chosen entirely random.

I previously had used context-sensitive to ensure both agents wouldn't remain active, but that event never occurs.
<<two-agent-solution.py>>=
def diffuse(swarm):
	for agent_num, agent in enumerate(swarm):

		# No self selection.
		# The polled agent is always the other agent.
		other_agent = swarm[(agent_num+1)%2]

		if not agent.active:

			if other_agent.active: # copy hyp noisily

				x, y, state = other_agent.hyp

				if random.random() < 0.3:

					x += random.choice([-1,1])

				if random.random() < 0.3:

					y += random.choice([-1,1])

				agent.hyp = Step(x, y, state=random.randint(1,4))

			else:

				agent.hyp = initial_hyp()	
@

That all seems fairly safe, I should point out that the randomisation of state in the transmission error will be mitigated if each agent existed within a swarm that defined a single state. To clarify this, rather than a single homogeneous swarm, imagine a swarm of agents in each row of the state table, then each swarm would ``know'' what they were hypothesising as the next state.

But now I need to determine a test phase. It would require checking if the other agent is active and if so, that your hypothesis is a valid transition (see function ``[[is_valid]]'').
There also needs to be the extra feature that the agents remain active once they've become active, and the surpress the activity of the other agent.

<<two-agent-solution.py>>=
def test():

	for agent_num, agent in enumerate(swarm):

		# Active agents do nothing, and stay active
		if not agent.active:

			other_agent = swarm[(agent_num+1)%2]

			if other_agent.active:

				# Check if transition is valid.

				valid = is_valid(agent.hyp, other_agent.hyp)

				agent.active = valid

				if valid:

					other_agent.active = False

			else:

				# Both agents are inactive.
				# Go active if you have the initial state.
				# This only runs once.

				agent.active = agent.hyp == initial_hyp()
@

Here's the [[is_valid]] function, which implements the state table manually.

<<two-agent-solution.py>>=
def `is_valid(hyp, prev_hyp):

	other_x, other_y, other_state = prev_hyp

	x, y, state = hyp

	if other_state == 1:

		if other_x == 0:

			return x == other_x and y == other_y and state == 4

		else:

			return x == other_x and y == other_y and state == 2

	elif other_state == 2:

		return x == other_x-1 and y == other_y and state == 3

	elif other_state == 3:

		if other_x == 0:

			return x == other_x and y == other_y+1 and state == 4

		else:

			return x == other_x and y == other_y+1 and state == 2

	else: # other_state == 4:

		return False
@

Now to add a loop that does intialise, test, diffuse and halt. We'll halt when any active agent is in halt state 4.

<<two-agent-solution.py>>=
def run():
	# Initialise
	for agent in swarm:
		agent.hyp = initial_hyp()

	previously_active_agent = 1

	for iteration in range(1000):

		test()

		diffuse(swarm)

		# Print to console when the inactive agent becomes active.
		active_agent = [agent.active for agent in swarm].index(True)

		if False or not (active_agent == previously_active_agent):

			print(
				format(iteration,'4'),
				[(agent.hyp,agent.active) for agent in swarm],)

			previously_active_agent = active_agent

		# Halting.
		if any(agent.hyp.state == 4 for agent in swarm if agent.active):

			print(
				'Answer is',
				next(
					agent.hyp
					for agent
					in swarm
					if agent.active and agent.hyp.state == 4).y,
				'in',iteration,'iterations.')

			break
	else:

		print('no convergence')
@

Here's a script to run the two agent solution. It works, but there are some potentially problematic aspects to it.

<<run-two-agent-solution.py>>=
import two_agent_solution

two_agent_solution.run()
@

\subsection{Problems with the Two Agent solution}

\begin{enumerate}
\item The complex logic in the test for validation.
\item The fact that there are only two agents, there's nothing swarmy.
\item Only inactive agents perform the test phase.
\end{enumerate}

\section{Multiple agent solution}

The idea is to have one swarm for every state in the NORMA2 state table, plus two for every unique conditional branch destination.

Each swarm will also have a boolean convergence flag, which is initially false.

Initialisation could be achieved either by setting all the agents in the initial swarm to certain register values, and setting the convergence flag, or setting a single agent active with certain register values and waiting for convergence.
Agents in the initial swarm will be set active and given register values.

Any swarm which has not converged will be polling connected swarms and diffusing perturbed hypotheses, which it will test as valid by checking that a random agent from the previous swarm is converged and the registers make sense with the polled agents registers.

When a swarm has full activity it sets its convergence flag, inviting activity from the subsequent swarms, and surpresses all activity in previous swarms by switching off its convergence flag. Convergence flags therefore surpress processing.

\subsection{Implementation}

Let's start off with some imports.

<<multi-swarm-solution.py>>=
import random
import sds
from collections import namedtuple
import functools

Step = namedtuple('Step',['x','y','state'])

def agent_repr(self):
	if self.active:
		return "{h}".format(h=self.hypothesis)
	else:
		return "inactive"
sds.Agent.__repr__ = agent_repr
@

Now I'll define some swarms, right now I'll just initialise them, I'll link them up later, as its much easier to link an acyclic graph once all nodes have been created.

I'm also including a `converged' flag for each swarm, and rather than just having a raw boolean [['False']], I've made it a boolean in a list [['[False]']] so I can zip the list and have something I can modify in place.

At the end of this chunk `swarms' is a list of \mbox{(swarm name, agent list, converged flag)} tuples.

<<>>=
agent_count = 5
swarm_names = ('init','xgt0','decx','incy','xeq0','halt')
swarms = {
	swarm_name:	{
		'converged': False,
		'agents': [sds.Agent() for _ in range(agent_count)]
	}
	for swarm_name
	in swarm_names
}
@

Now initialise all the agent in the first swarm as active at the initial step.

This action has to be considered carefully as it must be the case that this swarm never converges again. Once the convergence flag is on, it will stop processing, once the flag goes off again, there must never be any activity, so activity can't just come from the microtests. I therefore suggest that each agent in the init swarm selects an agent in the init swarm.

<<>>=
for agent in swarms['init']['agents']:
	agent.hypothesis = Step(x=10,y=10,state=None)
	agent.active = True

swarms['init']['converged'] = True
@

\subsection{Multi swarm definitions}

I'll define everything manually, but afterwards I should be able to make a sexy functional programming solution.

This is for the init swarm.
<<>>=
def init_hyp(rng=random):
	#print('init hyp runs')
	return Step(x=1000,y=1000,state=None)

def init_test(hyp):
	#print('init test runs')
	polled_agent = random.choice(swarms['init']['agents'])
	#return polled_agent.hypothesis == Step(x=3,y=2,state=None)
	return polled_agent.active

@

Before doing any of the other functions, we have to have a function to probabilistically perturb a register.

<<>>=
def perturb(register):
	if random.random() < 0.1:
		delta = random.choice((1,-1))
		register += delta
	return register
@

This is for `\(x > 0\)' swarm.

<<>>=
def xgt0_hyp(rng=random):
	for swarm_name in ('init','incy'):
		if swarms[swarm_name]['converged']:
			polled = rng.choice(swarms[swarm_name]['agents'])
			polled_x, polled_y, polled_state = polled.hypothesis
			return Step(x=perturb(polled_x),y=perturb(polled_y),state=None)
	else:
		return Step(x=0,y=0,state=None)

def xgt0_test(hyp):
	for swarm_name in ('init','incy'):
		if swarms[swarm_name]['converged']:
			polled_agent = random.choice(swarms[swarm_name]['agents'])
			break
	else:
		return False
	if polled_agent.active:
		polled_x, polled_y, _ = polled_agent.hypothesis
		return hyp.x == polled_x and hyp.y == polled_y and hyp.x > 0
	else:
		raise RuntimeError('inactive agent polled')
@

This is for `Decrement X' swarm.

<<>>=
def decx_hyp(rng=random):
	for swarm_name in ('xgt0',):
		if swarms[swarm_name]['converged']:
			polled = rng.choice(swarms[swarm_name]['agents'])
			polled_x, polled_y, polled_state = polled.hypothesis
			return Step(x=perturb(polled_x),y=perturb(polled_y),state=None)
	else:
		return Step(x=0,y=0,state=None)

def decx_test(hyp):
	if swarms['xgt0']['converged']:
		polled_agent = random.choice(swarms['xgt0']['agents'])
		if polled_agent.active:
			polled_x, polled_y, _ = polled_agent.hypothesis
			result = hyp.x == polled_x-1 and hyp.y == polled_y
			return result
		else:
			raise RuntimeError('inactive agent polled')
	else:
		print('dec x failed test as xgt0 is not converged')
		return False
@

This is for `Increment Y' swarm...
<<>>=
def incy_hyp(rng=random):
	for swarm_name in ('decx',):
		if swarms[swarm_name]['converged']:
			polled = rng.choice(swarms[swarm_name]['agents'])
			polled_x, polled_y, polled_state = polled.hypothesis
			return Step(x=perturb(polled_x),y=perturb(polled_y),state=None)
	else:
		return Step(x=0,y=0,state=None)

def incy_test(hyp):
	if swarms['decx']['converged']:
		polled_agent = random.choice(swarms['decx']['agents'])
		if polled_agent.active:
			polled_x, polled_y, _ = polled_agent.hypothesis
			result = hyp.x == polled_x and hyp.y == polled_y+1
			return result
		else:
			raise RuntimeError('inactive agent polled')
	else:
		print('incy failed test as decx is not converged')
		return False
@

This is for `\(x = 0\)' swarm.
<<>>=
def xeq0_hyp(rng=random):
	for swarm_name in ('init','incy'):
		if swarms[swarm_name]['converged']:
			polled = rng.choice(swarms[swarm_name]['agents'])
			polled_x, polled_y, polled_state = polled.hypothesis
			return Step(x=perturb(polled_x),y=perturb(polled_y),state=None)
	else:
		return Step(x=0,y=0,state=None)

def xeq0_test(hyp):
	for swarm_name in ('init','incy'):
		if swarms[swarm_name]['converged']:
			polled_agent = random.choice(swarms[swarm_name]['agents'])
			break
	else:
		return False
	if polled_agent.active:
		polled_x, polled_y, _ = polled_agent.hypothesis
		return hyp.x == polled_x and hyp.y == polled_y and hyp.x == 0
	else:
		raise RuntimeError('inactive agent polled')
@

This is for the halt swarm.
<<>>=
def halt_hyp(rng=random):
	for swarm_name in ('xeq0',):
		if swarms[swarm_name]['converged']:
			polled = rng.choice(swarms[swarm_name]['agents'])
			polled_x, polled_y, polled_state = polled.hypothesis
			return Step(x=perturb(polled_x),y=perturb(polled_y),state=None)
	else:
		return Step(x=0,y=0,state=None)

def halt_test(hyp):
	for swarm_name in ('xeq0',):
		if swarms[swarm_name]['converged']:
			polled_agent = random.choice(swarms[swarm_name]['agents'])
			break
	else:
		return False
	if polled_agent.active:
		polled_x, polled_y, _ = polled_agent.hypothesis
		return hyp.x == polled_x and hyp.y == polled_y
	else:
		raise RuntimeError('inactive agent polled')
@

Here's a data structure to keep it all together.
<<>>=
solution = [
	['init',swarms['init'],init_test,init_hyp,[]],
	['xgt0',swarms['xgt0'],xgt0_test,xgt0_hyp,['init','incy']],
	['decx',swarms['decx'],decx_test,decx_hyp,['xgt0']],
	['incy',swarms['incy'],incy_test,incy_hyp,['decx']],
	['xeq0',swarms['xeq0'],xeq0_test,xeq0_hyp,['init','incy']],
	['halt',swarms['halt'],halt_test,halt_hyp,['xeq0']],
]
@

\subsection{Multi-swarm execution}

<<>>=
def fully_active(swarm):
	result = all(x.active for x in swarm)
	return result

def iterate(solution):
	for swarm_name, swarm, microtest, hyp_function, previous_swarms in solution:
		if not swarm['converged']:
			#print('processing',swarm_name)
			# if swarm is not converged
			sds.run(
				swarm=swarm['agents'],
				microtests=[microtest],
				random_hypothesis_function=hyp_function,
				max_iterations=100,
				halting_function=fully_active,
				halting_iterations=10,
				report_iterations=None,
			)
			if not all(agent.active for agent in swarm['agents']):
				#raise RuntimeError('I thought it would all be active by now')
				#print(swarm_name,"didn't converge")
				pass
			else:
				swarm['converged'] = True
				print(swarm_name,'is now converged at',swarm['agents'][0].hypothesis)
				if swarm_name == 'halt':
					print('convergence in the halt swarm halts the process')
					return True
				for swarm_name, swarm, _, _, _ in solution:
					for prev_swarm_name in previous_swarms:
						if prev_swarm_name == swarm_name:
							if swarm['converged']:
								swarm['converged'] = False
								print(prev_swarm_name,'is no longer converged')
								for agent in swarm['agents']:
									agent.active = False
									agent.hypothesis = None

	#print('not halted yet')
	return False

do_naive_multiswarm_solution = False
if do_naive_multiswarm_solution:

	for num, swarm_name in enumerate(swarm_names,start=1):
		print(num, swarm_name, swarms[swarm_name])

	while True:
		if iterate(solution):
			print('halted properly')
			break

	print('done. Answer is',swarms['halt']['agents'][0].hypothesis.y)
@

\section{Multi swarm solution with functional programming}

I'll carry on editing the same file as there will be a lot of code sharing.

I need to make some 'intended action' functions to save me typing five different sets of logic.

<<>>=
def decrementX(hyp):
	hyp_x, hyp_y, _ = hyp
	return Step(hyp_x-1, hyp_y, None)

def decrementY(hyp):
	hyp_x, hyp_y, _ = hyp
	return Step(hyp_x, hyp_y-1, None)

def incrementX(hyp):
	hyp_x, hyp_y, _ = hyp
	return Step(hyp_x+1, hyp_y, None)

def incrementY(hyp):
	hyp_x, hyp_y, _ = hyp
	return Step(hyp_x, hyp_y+1, None)

def noop(hyp):
	hyp_x, hyp_y, _ = hyp
	return Step(hyp_x, hyp_y, None)

def Xeq0(x):
	return x == 0

def Xgt0(x):
	return x > 0

def Xdontcare(x):
	return True
@

This is a function to make all the test function for all the swarms.

<<>>=
def make_test_fun(swarms, linked_swarms,action,x_condition,rng=random):
	def generic_test_fun(
		swarms, 
		previous_swarm_names,
		intended_action_function,
		x_condition_function,
		rng,
		hyp,
	):
		for swarm_name in previous_swarm_names:
			if swarms[swarm_name]['converged']:
				polled_agent = rng.choice(swarms[swarm_name]['agents'])
				break
		else:
			return False
		if polled_agent.active:
			polled_x, polled_y, _ = intended_action_function(polled_agent.hypothesis)
			return (
				hyp.x == polled_x
				and hyp.y == polled_y
				and x_condition_function(hyp.x))
		else:
			raise RuntimeError('inactive agent polled')

	return functools.partial(generic_test_fun,swarms,linked_swarms,action,x_condition,rng)

#foo = make_hyp_fun(linked_swarms=['init','incy'],action=noop,x_condition=Xgt0)
@

This is a function to make all the hyp functions for all the swarms.

<<>>=
def make_hyp_fun(swarms, linked_swarms):
	def generic_hyp_fun(swarms, linked_swarms,rng=random):
		for swarm_name in linked_swarms:
			if swarms[swarm_name]['converged']:
				polled = rng.choice(swarms[swarm_name]['agents'])
				polled_x, polled_y, polled_state = polled.hypothesis
				return Step(x=perturb(polled_x),y=perturb(polled_y),state=None)
		else:
			return Step(x=0,y=0,state=None)
	return functools.partial(generic_hyp_fun, swarms, linked_swarms)
@

Here's are the functions to make the building blocks.

<<>>=
swarm_types = {
	'init':(noop,Xdontcare),
	'xgt0':(noop,Xgt0),
	'xeq0':(noop,Xeq0),
	'incy':(incrementY,Xdontcare),
	'decy':(decrementY,Xdontcare),
	'incx':(incrementX,Xdontcare),
	'decx':(decrementX,Xdontcare),
	'halt':(noop,Xdontcare),
}
@

Which can be used with a state table.

<<>>=
state_table = [
	('A-init','init',['A-init']),
	('B-xgt0','xgt0',['A-init','D-incy']),
	('C-decx','decx',['B-xgt0']),
	('D-incy','incy',['C-decx']),
	('E-xeq0','xeq0',['A-init','D-incy']),
	('halt','halt',['E-xeq0']),
]
@

Now let's try to build a multi swarm solution from the table.

<<>>=
def build_solution(state_table,initial_x,initial_y):
	swarms = {
		name: {
			'converged': False,
			'agents': [sds.Agent() for _ in range(agent_count)]
		}
		for name, swarm_type, linked_swarms in state_table
	}

	solution = []

	for name, swarm_type, linked_swarms in state_table:

		if swarm_type == 'init':
			swarm = swarms[name]
			for agent in swarm['agents']:
				agent.hypothesis = Step(x=initial_x,y=initial_y,state=None)
				agent.active = True
			swarm['converged'] = True

		action, x_condition = swarm_types[swarm_type]
		
		test_fun = make_test_fun(swarms, linked_swarms,action,x_condition,random)
		hyp_fun = make_hyp_fun(swarms, linked_swarms)

		solution.append((name,swarms[name],test_fun, hyp_fun, linked_swarms))

	return solution
@

<<>>=
do_functional_multiswarm_solution = True
if do_functional_multiswarm_solution:

	functional_solution = build_solution(state_table,initial_x=1000,initial_y=1000)

	while True:
		if iterate(functional_solution):
			break

	_,halt_swarm,_,_,_ = next(x for x in functional_solution if x[0] == 'halt')
	answer = halt_swarm['agents'][0].hypothesis.y
	print('Answer is',answer)
	#print('done. Answer is',['halt']['agents'][0].hypothesis.y)
@

<<>>=
	#solution[0][1] = make_test_fun(['init'],noop,Xdontcare,random)
	#solution[0][2] = make_hyp_fun(['init'])
	#solution[1][1] = make_test_fun(['init','incy'],noop,Xgt0,random)
	#solution[1][2] = make_hyp_fun(['init','incy'])
	#solution[2][1] = make_test_fun(['xgt0'],decrementX,Xdontcare,random)
	#solution[2][2] = make_hyp_fun(['xgt0'])
	#solution[3][1] = make_test_fun(['decx'],incrementY,Xdontcare,random)
	#solution[3][2] = make_hyp_fun(['decx'])
	#solution[4][1] = make_test_fun(['init','incy'],noop,Xeq0,random)
	#solution[4][2] = make_hyp_fun(['init','incy'])
	#solution[5][1] = make_test_fun(['xeq0'],noop,Xdontcare,random)
	#solution[5][2] = make_hyp_fun(['xeq0'])
@

\appendix{}

\section{Index}

\nowebindex{}

\section{Code Chunks}

\nowebchunks{}

\end{document}

\section{New script}
<<new script>>=
<<dependencies>>
<<hypothesis>>
<<perturbations>>
<<turing swarm>>
<<new hypothesis function>>
<<microtest function>>
<<turing swarms>>
<<initialise swarms>>
<<asynchronous execution>>
<<synchronous execution>>
<<action>>
@

\section{Hypothesis}
<<hypothesis>>=
XY = namedtuple('XY',('x','y'))
@

<<dependencies>>=
from collections import namedtuple
@

\section{perturbations}
<<perturbations>>=
noop = lambda xy: xy
incx = lambda xy: XY(xy.x+1, xy.y)
decx = lambda xy: XY(max(0,xy.x-1), xy.y)
incy = lambda xy: XY(xy.x, xy.y+1)
decy = lambda xy: XY(xy.x, max(0,xy.y-1))

perturbations = (noop, incx, decx, incy, decy)
@

\section{Turing Swarm}
<<turing swarm>>=
class TuringSwarm:

	def __init__(self, agent_count):

		self.agents = sds.Agent.initialise(agent_count)

	def link(self, swarms):

		self.links = swarms

		self.new_hyp_fun = functools.partial(
			generic_new_hyp_function,
			linked_swarms=self.links,
		)

		self.microtest = [
			functools.partial(
				generic_microtest,
				action=self.action,
				linked_swarms=self.links,
			)
		]
@

<<dependencies>>=
import sds
import functools
@

\section{Generic New Hypothesis Function}
<<new hypothesis function>>=
def generic_new_hyp_function(random, linked_swarms):

	polled_swarm = random.choice(linked_swarms)

	polled_agent = random.choice(polled_swarm.agents)

	polled_hypothesis = polled_agent.hypothesis

	random_perturbation = random.choice(perturbations)

	return random_perturbation(polled_hypothesis)
@

<<dependencies>>=
import random
@

\section{Generic Microtest Function}

If you don't require your polled agent to be active, then the initialisation swarm will always be fully active, which dominates the execution.

<<microtest function>>=
def generic_microtest(hypothesis, action, linked_swarms):

	polled_swarm = random.choice(linked_swarms)

	polled_agent = random.choice(polled_swarm.agents)

	polled_hypothesis = polled_agent.hypothesis

	modified_hypothesis = action(polled_hypothesis)

	return (
		(modified_hypothesis is not None)
		and (modified_hypothesis == hypothesis)
	)
@

\section{Turing Swarm definitions}
<<turing swarms>>=
<<init>>
<<halt>>
<<xgt0>>
<<xeq0>>
<<incx>>
<<decx>>
<<incy>>
<<decy>>
@

\subsection{Init swarm}
<<init>>=
class Init(TuringSwarm):

	def __init__(self, agent_count, initial_hyp):

		super().__init__(agent_count)

		self.new_hyp_fun = lambda random: initial_hyp

		self.microtest = [lambda hyp: hyp == initial_hyp]
@

\subsection{Halt swarm}
<<halt>>=
class Halt(TuringSwarm):

	def action(self, hyp):
		return noop(hyp)
@

\subsection{$X > 0$ swarm}
<<xgt0>>=
class XGt0(TuringSwarm):

	def action(self, hyp):
		if hyp.x > 0:
			return hyp
		else:
			return None
@

\subsection{$X = 0$ swarm}
<<xeq0>>=
class XEq0(TuringSwarm):

	def action(self, hyp):
		if hyp.x == 0:
			return hyp
		else:
			return None
@

\subsection{Inc X swarm}
<<incx>>=
class IncX(TuringSwarm):

	def action(self, hyp):
		return incx(hyp)
@

\subsection{Dec X swarm}
<<decx>>=
class DecX(TuringSwarm):

	def action(self, hyp):
		return decx(hyp)
@

\subsection{Inc Y swarm}
<<incy>>=
class IncY(TuringSwarm):

	def action(self, hyp):
		return incy(hyp)
@

\subsection{Dec Y swarm}
<<decy>>=
class DecY(TuringSwarm):

	def action(self, hyp):
		return decy(hyp)
@

\section{Initialise swarms}
<<initialise swarms>>=
def initialise_swarms(swarms):
	for swarm in swarms:
		for agent in swarm.agents:
			agent.hypothesis = XY(
				x=random.randint(0,9),
				y=random.randint(0,9),)
@

\section{Asynchronous Execution}
<<asynchronous execution>>=
def asynchronous_execution(swarms, max_iterations):

	swarm_names = ('init','X>0','decX','incY','X==0','halt')

	named_swarms = list(zip(swarm_names,swarms))

	for iteration in range(max_iterations):

		for name, swarm in random.sample(named_swarms,len(named_swarms)):

			sds.passive_diffusion(swarm.agents, random, swarm.new_hyp_fun)

			sds.test_phase(swarm.agents, swarm.microtest, random)

		active_counts = [
			Counter(tuple(agent.hypothesis) for agent in swarm.agents if agent.active).most_common(2)
			for swarm
			in swarms
		]

		print("{x:2}".format(x=iteration+1), list(zip(swarm_names,active_counts)))
@

\section{Synchronous Execution}
<<synchronous execution>>=
def synchronous_execution(swarms, max_iterations):

	swarm_names = ('init','X>0','decX','incY','X==0','halt')

	for iteration in range(max_iterations):

		for swarm in swarms:

			sds.context_sensitive_diffusion(swarm.agents, random, swarm.new_hyp_fun)

		for swarm in swarms:

			sds.test_phase(swarm.agents, swarm.microtest, random)

		active_counts = [
			Counter(tuple(agent.hypothesis) for agent in swarm.agents if agent.active).most_common(2)
			for swarm
			in swarms
		]

		print("{x:2}".format(x=iteration+1), list(zip(swarm_names,active_counts)))
		#print("{x:2}".format(x=iteration+1), 'x>0',active_counts[1])
		#print("{x:2}".format(x=iteration+1), )
@

<<dependencies>>=
from pprint import pprint
from collections import Counter
@

\section{Action}
<<action>>=
my_init = Init(agent_count=100, initial_hyp=XY(2,3))
my_xgt0 = XGt0(agent_count=100)
my_xeq0 = XEq0(agent_count=100)
my_halt = Halt(agent_count=100)
my_decx = DecX(agent_count=100)
my_incy = IncY(agent_count=100)

my_xgt0.link((my_init, my_incy))
my_xeq0.link((my_init, my_incy))
my_halt.link((my_xeq0,))
my_decx.link((my_xgt0,))
my_incy.link((my_decx,))

swarms = [ my_init, my_xgt0, my_decx, my_incy, my_xeq0, my_halt]

initialise_swarms(swarms)

synchronous_execution(swarms,max_iterations=500)
print('Done')
@


